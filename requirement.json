[
    {
        "name": "F1",
        "normalProcess": "An authenticator handles the authentication challenge/response cycles of a single connection."
    },
    {
        "name": "F2",
        "normalProcess": "Cassandra includes integrated caching and distributes cache data around the cluster."
    },
    {
        "name": "F3",
        "normalProcess": "Cassandra provides a built-inow cacheor super-fast access to frequently requested data, competitive with standalone caching products."
    },
    {
        "name": "F4",
        "normalProcess": "Since Cassandra provides a durable database behind the cache, it can save your cache to disk periodically and read the contents back in when it restarts, so you never have to start with a cold cache."
    },
    {
        "name": "F5",
        "normalProcess": "The Cassandra Command Line Interface, CLI, client utility can be used to do basic data definition (DDL) and data manipulation (DML) within a Cassandra cluster."
    },
    {
        "name": "F6",
        "normalProcess": "Executes a sequence of (statement, parameters) tuples concurrently."
    },
    {
        "name": "F7",
        "normalProcess": "Cassandra exposes a number of statistics and management operations via Java Management Extensions (JMX). Java Management Extensions (JMX) is a Java technology that supplies tools for managing and monitoring Java applications and services. During normal operation, Cassandra outputs information and statistics that you can monitor using JMX-compliant toolsAny statistic or operation that a Java application has exposed as an MBean can then be monitored or manipulated using JMX."
    },
    {
        "name": "F8",
        "normalProcess": "In Cassandra, you define column families. Column families can (and should) define metadata about the columns, but the actual columns that make up a row are determined by the client application. Each row can have a different set of columns."
    },
    {
        "name": "F9",
        "normalProcess": "Node-to-node encryption protects data transferred between nodes, including gossip communication, in a cluster using SSL (Secure Sockets Layer)."
    },
    {
        "name": "F10",
        "normalProcess": "The keyspace is the container for your application data, similar to a schema in a relational database. Keyspaces are used to group column families together. Typically, a cluster has one keyspace per application."
    },
    {
        "name": "F11",
        "normalProcess": "Replication is the process of storing copies of data on multiple nodes to ensure reliability and fault tolerance.To determine the physical location of nodes and their proximity to each other, the replication strategy also relies on the cluster-configured snitch, which is described below."
    },
    {
        "name": "F12",
        "normalProcess": "Cassandra Query Language (CQL)."
    },
    {
        "name": "F13",
        "normalProcess": "A BATCH statement combines multiple data modification (DML) CQL statements into a single logical operation. BATCH supports setting a client-supplied, global consistency level and timestamp that is used for each of the operations included in the batch."
    },
    {
        "name": "F14",
        "normalProcess": "Developers can access CQL commands in a variety of ways such as JDBC-based client programs."
    },
    {
        "name": "F15",
        "normalProcess": "A counter is a special kind of column used to store a number that incrementally counts the occurrences of a particular event or process. For example, you might use a counter column to count the number of times a page is viewed. Counter columns are different from regular columns in that once a counter is defined, the client application then updates the column value by incrementing (or decrementing) it."
    },
    {
        "name": "F16",
        "normalProcess": "A column can also have an optional expiration date called TTL (time to live). Whenever a column is inserted, the client request can specify an optional TTL value, defined in seconds, for the column."
    },
    {
        "name": "F17",
        "normalProcess": "A Cassandra column family can contain either regular columns or super columns, which adds another level of nesting to the regular column family structure. Super columns are comprised of a (super) column name and an ordered map of sub-columns. A super column can specify a comparator on both the super column name as well as on the sub-column names."
    },
    {
        "name": "F18",
        "normalProcess": "Hinted handoff is an optional feature of Cassandra that reduces the time to restore a failed node to consistency once the failed node returns to the cluster. It can also be used for absolute write availability for applications that cannot tolerate a failed write, but can tolerate inconsistent reads"
    },
    {
        "name": "F19",
        "normalProcess": "Cassandra supports row mutation."
    },
    {
        "name": "F20",
        "normalProcess": "Cassandra writes are first written to theç‡™ommitLog, and then to a per-ColumnFamily structure called a Memtable. A Memtable is basically a write-back cache of data rows that can be looked up by key -- that is, unlike a write-through cache, writes are batched up in the Memtable until it is full, when it is flushed."
    },
    {
        "name": "F21",
        "normalProcess": "When thresholds are reached, Cassandra periodically flushes in-memory data structures (memtables) to SSTable data files for persistent storage of column family data."
    },
    {
        "name": "F22",
        "normalProcess": "Most applications can be designed with a data model that supports ordered queries as slices over a set of columns rather than range scans over a set of rows."
    },
    {
        "name": "F23",
        "normalProcess": "When a Memtable is full, Cassandra writes to disk as an SSTable. SSTable - sorted string table, key/value storage sorted by keys. SSTable is on-disk data structure and is always immutable."
    },
    {
        "name": "F24",
        "normalProcess": "A TRUNCATE statement results in the immediate, irreversible removal of all data in the named column family."
    },
    {
        "name": "F25",
        "normalProcess": "Marshal defines Cassandra operations for persistence of complex Haskell data objects with custom-selected but implicitly performed serialization."
    },
    {
        "name": "F26",
        "normalProcess": "In the background, Cassandra periodically merges SSTables together into larger SSTables using a process called compaction. Compaction merges row fragments together, removes expired tombstones (deleted columns), and rebuilds primary and secondary indexes."
    },
    {
        "name": "F27",
        "normalProcess": "Adds WHERE arguments to the queryset, returning a new queryset and Returns a QuerySet filtered on the keyword arguments."
    },
    {
        "name": "F28",
        "normalProcess": "Unlike almost every other configuration choice in Cassandra, the partitioner cannot be changed without reloading all of your data. Therefore, it is important to choose and configure the correct partitioner before initializing your cluster."
    },
    {
        "name": "F29",
        "normalProcess": "The RandomPartitioner is the default partitioning strategy for a Cassandra cluster, and in almost all cases is the right choice. The RandomPartitioner uses consistent hashing to determine which node stores which row."
    },
    {
        "name": "F30",
        "normalProcess": "Assumes keys are UTF8 strings. Not recommended both because of this limitation and because globally ordering all your partitions generates hot spots: some partitions close together will get more activity than others, and the node hosting those will be overloaded relative to others."
    },
    {
        "name": "F31",
        "normalProcess": "Cassandra provides the ByteOrderedPartitioner forordered partitioning. This partitioner orders rows lexically by key bytes. An order-preserving partitioner that operates on partition key bytes lexicographically."
    },
    {
        "name": "F32",
        "normalProcess": "Failure detection is a method for locally determining, from gossip state, if another node in the system is up or down. Failure detection information is also used by Cassandra to avoid routing client requests to unreachable nodes whenever possible."
    },
    {
        "name": "F33",
        "normalProcess": "The gossip process tracks heartbeats from other nodes both directly (nodes gossiping directly to it) and indirectly (nodes heard about secondhand, thirdhand, and so on)Gossip is a peer-to-peer communication protocol in which nodes periodically exchange state information about themselves and about other nodes they know about. The gossip process runs every second and exchanges state messages with up to three other nodes in the cluster. The nodes exchange information about themselves and about the other nodes that they have gossiped about, so all nodes quickly learn about all other nodes in the cluster. A gossip message has a version associated with it, so that during a gossip exchange, older information is overwritten with the most current state for a particular node. Cassandra uses a protocol called gossip to discover location and state information about the other nodes participating in a Cassandra cluster."
    },
    {
        "name": "F34",
        "normalProcess": "allows you to read data stored in Cassandra from a Hadoop MapReduce job, and its companion class and  to write the results back into Cassandra."
    },
    {
        "name": "F35",
        "normalProcess": "Cassandra 1.0 introduces support for data compression on a per-ColumnFamily basis, one of the most-requested features since the project started. Compression maximizes the storage capacity of your Cassandra nodes by reducing the volume of data on disk."
    },
    {
        "name": "F36",
        "normalProcess": "A snitch maps IPs to racks and data centers. It defines how the nodes are grouped together within the overall network topology.  A snitch determines which data centers and racks nodes belong to. Snitches inform Cassandra about the network topology so that requests are routed efficiently and allows Cassandra to distribute replicas by grouping machines into data centers and racks."
    },
    {
        "name": "F37",
        "normalProcess": "By default, all snitches also use a dynamic snitch layer that monitors read latency and, when possible, routes requests away from poorly-performing nodes. The dynamic snitch is enabled by default and is recommended for use in most deployments."
    },
    {
        "name": "F38",
        "normalProcess": "The SimpleSnitch (the default) does not recognize data center or rack information. Use it for single-data center deployments (or single-zone in public clouds)."
    },
    {
        "name": "F39",
        "normalProcess": "The RackInferringSnitch determines the location of nodes by rack and data center, which are assumed to correspond to the 3rd and 2nd octet of the node's IP address, respectively. Use this snitch as an example of writing a custom Snitch class."
    },
    {
        "name": "F40",
        "normalProcess": "This snitch uses a user-defined description of the network details located in the assandra-topology.propertiesfile. Use this snitch when your node IPs are not uniform or if you have complex replication grouping requirements. When using this snitch, you can define your data center names to be whatever you want."
    },
    {
        "name": "F41",
        "normalProcess": "Use the Ec2Snitch for simple cluster deployments on Amazon EC2 where all nodes in the cluster are within a single region. The region is treated as the data center and the availability zones are treated as racks within the data center."
    },
    {
        "name": "F42",
        "normalProcess": "Use the EC2MultiRegionSnitch for deployments on Amazon EC2 where the cluster spans multiple regions. As with the Ec2Snitch, regions are treated as data centers and availability zones are treated as racks within a data center."
    },
    {
        "name": "F43",
        "normalProcess": "A new connection between nodes will either stream or message, determining the connection type."
    },
    {
        "name": "F44",
        "normalProcess": "All ports in cassandra are TCP."
    },
    {
        "name": "F45",
        "normalProcess": "Cassandra uses one thread-per-client for remote procedure calls. For a large number of client connections, this can cause excessive memory usage for the thread stack. cassandra defines a scheduler to handle incoming client requests according to a defined policy. This scheduler only applies to client requests, not inter-node communication."
    },
    {
        "name": "F46",
        "normalProcess": "Cassandra has A Factory for providing and setting up Client and Server SSL wrapped Socket and ServerSocket."
    },
    {
        "name": "F47",
        "normalProcess": "In cassandrathe Thrift interface is a legacy API for older clients. Thrift is an interface definition language and binary communication protocol that is used to define and create services for numerous languages. It is used as a remote procedure call (RPC) framework."
    },
    {
        "name": "F48",
        "normalProcess": "Streaming is a component which handles data (part of SSTable file) exchange among nodes in the cluster. When you bootstrap a new node, it gets data from existing nodes using streaming."
    },
    {
        "name": "F49",
        "normalProcess": "Update CQL to generate microsecond timestamps by default. cassandra-cli use micro second timestamp, but CQL use milli second. cassandra-cli set micro second timestamp by FBUtilities.timestampMicros. But CQL insert or update operation set milli second timestamp by AbstractModification.getTimestamp. If you register data by cassandra-cli, you can't update data by CQL. Because CQL timestamp is judged as past time."
    },
    {
        "name": "F50",
        "normalProcess": "Fix counting CFMetadata towards Memtable liveRatio. NPE in describe_ring. I have a 2 DC, 2 node per DC cluster. DC1 had it's seed replaced but I hadn't restarted. I upgraded to 0.8.4 in the following fashion: -edited seeds -stopped both DC1 nodes -upgraded jars -started both nodes at the same time The non-seed node came up first and showed the following error. Then when the seed node came up, the error went away on the non-seed node but started occurring on the seed node."
    },
    {
        "name": "F51",
        "normalProcess": "Kill server on wrapped OOME such as from FileChannel.map. When a mmap fails, Cassandra should exit."
    },
    {
        "name": "F52",
        "normalProcess": "remove unnecessary copy when adding to row cache. probably don't need to do full copy to row cache after un-mmap() change. If so, maybe slightly better performance in both speed and memory."
    },
    {
        "name": "F53",
        "normalProcess": "Log message when a full repair operation completes. Log message at INFO when a global or keyspace level repair operation completes. If JMX times out it's difficult to tell when repair completes.Right now we log at DEBUG for each column family but we need a way to tell when the repair operation completes as a whole."
    },
    {
        "name": "F54",
        "normalProcess": "Fix streamOutSession keeping sstables references forever if the remote end dies. A streamOutSession keeps sstables references forever if the remote end dies. A streamOutSession acquire a reference on the sstable it will stream and release them as soon as each sstable has been fully streamed. However, since a stream session has currently no means to know when it failed, we'll keep references indefinitely (meaning until next restart) if their is a failure. One way a stream session could very easily fail is if the remote end dies. We must make sure we correctly release sstable references when that happens."
    },
    {
        "name": "F55",
        "normalProcess": "Remove dynamic_snitch boolean from example configuration (defaulting to true) and set default badness threshold to 0.1. Remove ability to disable dynamic snitch entirely. We've moved dynamic snitch from new, default to off to well tested, default to true,and it's time now to take the next step to there is no reason to disable it, and keeping the option around just lets people shoot their foot off."
    },
    {
        "name": "F56",
        "normalProcess": "Base choice of random or balanced token on bootstrap on whether schema definitions were found. Nodes started at the same time end up with the same token. Since auto boostrap is defaulted to on when you start a cluster at once, you can end up with nodes being assigned the same token."
    },
    {
        "name": "F57",
        "normalProcess": "Fixes for LeveledCompactionStrategy score computation, prioritization, scheduling, and performance. LeveledCompactionStrategy is too complacent. BF size calculation doesn't take into account LCS breaking the output apart into bite sized sstables, so memory use is much higher than predicted. ManyToMany merging is slow. At least part of this is from running the full reducer machinery against single input sources, which can be optimized away."
    },
    {
        "name": "F58",
        "normalProcess": "Parallelize sstable open at server startup. Improve SSTableReader.load() when loading index files."
    },
    {
        "name": "F59",
        "normalProcess": "Fix handling of exceptions writing to Outbound Tcp Connection. Outbound Tcp Connection throws RuntimeException."
    },
    {
        "name": "F60",
        "normalProcess": "Allow using quotes in USE keyspace CLI command. In the CLI USE keyspace doesn't work for numeric keyspaces."
    },
    {
        "name": "F61",
        "normalProcess": "Don't allow any cache loading exceptions to halt startup. Failure reading a erroneous/spurious AutoSavingCache file can result in a failed application of a migration, which can prevent a node from reaching schema agreement."
    },
    {
        "name": "F62",
        "normalProcess": "Fix sstableloader --ignores option. sstableloader ignores option doesn't work correctly. The --ignores option is supposed to take an argument but it doesn't."
    },
    {
        "name": "F63",
        "normalProcess": "File descriptor limit increased in packaging. increase file descriptor limit in deb, rpm packages."
    },
    {
        "name": "F64",
        "normalProcess": "Fix deadlock in commit log during flush. inherent deadlock situation in commitLog flush."
    },
    {
        "name": "65",
        "normalProcess": "Log a meaningful warning when a node receives a message for a repair session that doesn't exist anymore. AssertionError when repairing a node."
    },
    {
        "name": "66",
        "normalProcess": "Test for NUMA policy support as well as numactl presence. Don't fail when numactl is installed, but NUMA policies are not supported."
    },
    {
        "name": "67",
        "normalProcess": "Fix FD leak when internode encryption is enabled. Enabling SSL on a fairly light cluster leaks Open files."
    },
    {
        "name": "68",
        "normalProcess": "MergeIterator.get assert that it don't get an empty list of sources.Remove incorrect assertion in mergeIterator. MergeIterator assertion on sources != empty can be thrown."
    },
    {
        "name": "69",
        "normalProcess": "FBUtilities.hexToBytes(String) to throw NumberFormatException when string contains non-hex characters. CQL does not throw an error when invalid hex is supplied."
    },
    {
        "name": "70",
        "normalProcess": "Keep SimpleSnitch proximity ordering unchanged from what the Strategy generates, as intended. Simple Snitch.compareEndpoints doesn't respect the intent of the snitch. SimpleSnitch is supposed to not sort the input addresses, thus respecting the order of the partitioner."
    },
    {
        "name": "71",
        "normalProcess": "Remove Scrub from compactionstats when finished. Sstable scrub status persists in compactionstats after scrub is complete. When scrubbing the sstables on a node, the 'Scrub' info persists in the 'compactionstats' nodetool utility, even after the scrub is complete."
    },
    {
        "name": "72",
        "normalProcess": "Fix counter entry in jdbc TypesMap. Cannot read counter value from jdbc cql."
    },
    {
        "name": "73",
        "normalProcess": "Fix full queue scenario for ParallelCompactionIterator. Error during multi-threaded compaction. I'm running 0.8.6 plus the multi-threaded compaction patch in issue 2901. I'm getting an error compacting"
    },
    {
        "name": "74",
        "normalProcess": "Fix bootstrap process. Bootstrap is broken in 1.0.0-rc1. The condition to bootstrap is that there are non-system tables instead, a not is missing, and the setToken() was wrongly push up into the I'm not bootstrapping block so a boostrapping node was left in the joining state."
    },
    {
        "name": "75",
        "normalProcess": "Fix bootstrap process. Bootstrap is broken in 1.0.0-rc1.  the condition to bootstrap is that there are non-system tables instead, a not is missing, and the setToken() was wrongly push up into the I'm not bootstrapping block so a boostrapping node was left in the joining state."
    },
    {
        "name": "76",
        "normalProcess": "CLI documentation change for ColumnFamily `compression_options`. CLI does not support removing compression options from a ColumnFamily."
    },
    {
        "name": "77",
        "normalProcess": "Ignore any CF ids sent by client for adding CF/KS. CfDef can default to an invalid id and fail during system_add_column_family."
    },
    {
        "name": "78",
        "normalProcess": "Remove obsolete hints on first startup. 1.0 needs to clean out old-style hints."
    },
    {
        "name": "79",
        "normalProcess": "Use correct ISortedColumns for time-optimized reads. assert err on ArrayBackedSortedColumns.addColumn. every thing is flushed to the sstables, but not in the same sstables, and the columns are in some what 'random' form."
    },
    {
        "name": "80",
        "normalProcess": "Evict gossip state immediately when a token is taken over by a new IP. Replace token leaves the old node state in tact causing problems in cli. in the replace token patch we dont evict the node from the Gossip which will leave the node lingering around and causes issues in cli (UNReachable nodes) As a part of the replace token if the token is replaced with another token we should remove the old nodes Gossip states."
    },
    {
        "name": "81",
        "normalProcess": "Close scrubbed sstable fd before deleting it. Unable to delete after running scrub. Another problem with sstable deletions on 1.0. Running scrub produces lot of unable to delete messages on windows."
    },
    {
        "name": "82",
        "normalProcess": "Fix bug preventing obsolete commitlog segments from being removed. possible early deletion of commit logs. I ran my cluster for about 2 days. the cluster has 2 nodes. I restarted one box several times, and the other one was always running. the one always running ended up accumulating 100GB of commit logs."
    },
    {
        "name": "83",
        "normalProcess": "Tolerate whitespace in seed CDL. Whitespace in SimpleSeedProvider string makes seed ignored. If a seeds given to SimpleSeedProvider contains whitespace, the seed will be ignored."
    },
    {
        "name": "84",
        "normalProcess": "Change default heap thresholds to max(min(1/2 ram, 1G), min(1/4 ram, 8GB)). reduce default heap size. With off-heap caching now the default and with auto-flushed memtables demonstrated to do a good job with smaller heaps, I think it's time to reduce heap sizes to decrease GC pause times."
    },
    {
        "name": "85",
        "normalProcess": "Fix broken CompressedRandomAccessReaderTest. CompressedRandomAccessReaderTest fails on Windows."
    },
    {
        "name": "86",
        "normalProcess": "(CQL) fix type information returned for wildcard queries. cqlsh: Error running select * vs select all columns"
    },
    {
        "name": "87",
        "normalProcess": "Add estimated tasks to LeveledCompactionStrategy. add estimated tasks to LeveledCompactionStrategy."
    },
    {
        "name": "88",
        "normalProcess": "Avoid including compaction cache-warming in keycache stats. Compaction degrades key cache stats. When compaction_preheat_key_cache is set to true, then during compaction, it keep tracks of cached keys to to re-cache their new position. It does this by calling the following method on every key of the compacted sstable : sstable.getCachedPosition(row.key) which also update cache stats, thus lowering hit rate."
    },
    {
        "name": "89",
        "normalProcess": "Run compaction and hinted handoff threads at MIN_PRIORITY. Add compaction_thread_priority back. This turns out to be false in the majority of deployments. In many (if not most) situations, compaction is actually CPU bound, not IO bound, so multithreaded compaction is generally helpful, but the priority needs to be lowered in order to prevent it from stealing CPU used for reads/writes."
    },
    {
        "name": "90",
        "normalProcess": "Default hsha thrift server to cpu core count in rpc pool. make HSHA the default Thrift server. HSHA has been an option since 0.8.3."
    },
    {
        "name": "91",
        "normalProcess": "Add bin daemon to binary tarball for Windows service. Apache Daemon missing from the binary tarball. Apparently the tools used to run the binary release are missing from the binary tarball. I will verify that they are in the 1.0 branch, then update the ticket so we can ensure that they are included."
    },
    {
        "name": "92",
        "normalProcess": "Fix places where uncompressed size of sstables was use in place of the compressed one. Uncompressed sizes are used to estimate space for compaction of compressed sstables. We are using the uncompressed data size when estimating if we have enough to compact sstables. This means we can easily refuse compaction when there is clearly enough room to compact."
    },
    {
        "name": "93",
        "normalProcess": "Fix hsha thrift server. HsHa broken at startup."
    },
    {
        "name": "94",
        "normalProcess": "Make sure repair only stream needed sstables. Repair still streams unnecessary sstables. unfortunately got committed with the use of the wrong streaming method, the one that stream all the sstables of the keyspace."
    },
    {
        "name": "F95",
        "normalProcess": "Acquire references during index build to prevent delete problems on Windows. Fail to delete -Index files if index is currently building. If there is index building in progress, following errors are thrown if cassandra is trying to delete *-Index.db files."
    },
    {
        "name": "F96",
        "normalProcess": "Describe_ring should include datacenter/topology information. describe_ring should include datacenter/topology information. describe_ring is great for getting a list of nodes in the cluster, but it doesn't provide any information about the network topology which prevents it's use in a multi-dc setup. It would be nice if we added another list to the TokenRange object containing the DC information."
    },
    {
        "name": "F97",
        "normalProcess": "Thrift sockets are not properly buffered. Thrift sockets are not buffered properly. adds back BufferedInputStream and BufferedOutputStream to TSocket in new TCustomSocket class."
    },
    {
        "name": "F98",
        "normalProcess": "performance improvement for bytebufferutil compare function. Performance issue in ByteBufferUtil. Profiling 1.0 we can see ByteBufferUtil.compareUnsigned is slow. We can avoid the problem when the ByteBuffer has a backing array."
    },
    {
        "name": "F99",
        "normalProcess": "Add system.versions ColumnFamily. Expose server, api versions to CQL. Need to expose the CQL api version; might as well include the server version while we're at it."
    },
    {
        "name": "F100",
        "normalProcess": "Reduce network copies. remove more copies from read/write network path. RowMutation.serializedBuffer and ReadVerbHandler both do an extra copy of the serialized data. We can avoid this be pre-computing the serialized size and allocating an appropriate buffer. ReadResponseSerializer doesn't compute serialized size correctly."
    },
    {
        "name": "F101",
        "normalProcess": "limit nodetool to 32MB of heap. java heap limit for nodetool."
    },
    {
        "name": "F102",
        "normalProcess": "(CQL) update parser to accept timestamp instead of date. Update CQL type names to match expected (SQL) behavor."
    },
    {
        "name": "F103",
        "normalProcess": "Fix CLI `show schema` to include compression_options. show schema' in cli does not show compression_options. using the cassandra-cli command line tool, I realized that a 'show schema' does not print out the compression_options I specified when creating them."
    },
    {
        "name": "F104",
        "normalProcess": "Snapshot to include manifest under LeveledCompactionStrategy. snapshot should include manifest under leveledcompaction."
    },
    {
        "name": "F105",
        "normalProcess": "(CQL) SELECT query should allow CF name to be qualified by keyspace. CQL queries should alow talbe names to be qualified by keyspace."
    },
    {
        "name": "F106",
        "normalProcess": "(CQL) Fix internal application error specifying 'using consistency ...' in lower case. CQL: Internal application error specifying 'using consistency ...' in lower case; must be upper case."
    },
    {
        "name": "F107",
        "normalProcess": "Fix Deflate compression when compression actually makes the data bigger. Deflate Compression corrupts SSTables. it seems that the Deflate Compressor corrupts the SSTables. 3 out of 3 Installations were corrupt. Snappy works fine."
    },
    {
        "name": "F108",
        "normalProcess": "Optimize UUIDGen to avoid lock contention on InetAddress.getLocalHost. unnecessary locking in hint path due to InetAddress.getLocalhost()."
    },
    {
        "name": "F109",
        "normalProcess": "Tolerate index being dropped mid-mutation. dropping index causes some inflight mutations to fail. dropping index causes some inflight mutations to fail. hector on client side didnt throw any exception. Cancelling index build throws assert error."
    },
    {
        "name": "F110",
        "normalProcess": "CompactionManager is now responsible for checking for new candidates post-task execution, enabling more consistent leveled compaction. CFM.toAvro() incorrectly serialises key_validation_class defn. "
    },
    {
        "name": "F111",
        "normalProcess": "Cache HSHA threads. Make HSHA cached threads. JDK's newCachedTP does the following."
    },
    {
        "name": "F112",
        "normalProcess": "Use CF/KS names as snapshot prefix for drop + truncate operations. Enhance human-readability of snapshot names created by drop column family."
    },
    {
        "name": "F113",
        "normalProcess": "Break bloom filters up to avoid heap fragmentation. bloom filters should avoid huge array allocations to avoid fragmentation concerns.The fact that bloom filters are backed by single large arrays of longs is expected to interact badly with promotion of objects into old gen with CMS, due to fragmentation concerns."
    },
    {
        "name": "F114",
        "normalProcess": "Fix cassandra hanging on jsvc stop. stop Cassandra result in hang."
    },
    {
        "name": "F115",
        "normalProcess": "Avoid leveled compaction getting blocked on errors. LeveledCompactionTask is too fragile and can block compactions. If any error happens during a LeveledCompactionTask, it will just block every compaction."
    },
    {
        "name": "F116",
        "normalProcess": "Make reloading the compaction strategy safe. CFS reloading of the compaction strategy is done for every metadata update and is not thread safe. The reloading of the compaction strategy done during CFS.reload is not thread safe. In particular, this is a problem for leveled compactions."
    },
    {
        "name": "F117",
        "normalProcess": "Ignore 0.8 hints even if compaction begins before we try to purge them. NPE in hinted handoff."
    },
    {
        "name": "F118",
        "normalProcess": "Remove procrun (bin daemon) from Cassandra source tree and artifacts. Apache Daemon missing from the binary tarball."
    },
    {
        "name": "F119",
        "normalProcess": "Make cassandra compile under JDK7. Currently system won't compile under JDK 7 because of errors in CQL JDBC component."
    },
    {
        "name": "F120",
        "normalProcess": "Remove dependency of clientutil.jar to FBUtilities. clientutil depends on FBUtilities. clientutils' (indirect )dependency on FBUtilities (needed for tests) would result in huge numbers of classes being pulled in transitively.The attached patch moves the bytesToHex and hexToBytes methods into a new class (o.a.c.utils.Hex), which has no external dependencies."
    },
    {
        "name": "F121",
        "normalProcess": "Avoid truncation errors by using long math on long values. use long math, if you want long results. Code calculates long values, using integer intermediate input, which can cause truncation errors, safer just to use long input."
    },
    {
        "name": "F122",
        "normalProcess": "Avoid clock drift on some Windows machine. Avoid clock drift on some Windows machines. Performing Thread.sleep() with non-rounded values increases the frequency of interrupts on Windows machines; this can cause performance problems, and on some machines even clock drift problems for the duration of the sleep."
    },
    {
        "name": "F123",
        "normalProcess": "Display cache provider in cli 'describe keyspace' command. it would be nice if describe keyspace in cli shows Cache Provider. Describe keyspace in the cli doesn't show the cache provider it would be nice to show it to verify the settings."
    },
    {
        "name": "F124",
        "normalProcess": "Fix incomplete topology information in describe_ring. describe_ring topology information is wrong/incomplete.  topology information was added to describe_ring, however it asks the gossiper for the DC information, and the gossiper can only have this with a gossip-enabled snitch, which currently means the Ec2Snitch. Instead, it should be asking the snitch for the DC for each endpoint."
    },
    {
        "name": "F125",
        "normalProcess": "Expire dead gossip states based on time. Expire dead gossip states based on time. Currently dead states are held until aVeryLongTime,3 days. The problem is that if a node reboots within this period, it begins a new 3 days and will repopulate the ring with the dead state."
    },
    {
        "name": "F126",
        "normalProcess": "Improve CompactionTask extensibility. CompactionTask is still fairly coupled to SizeTieredCompaction, including some ugly casting."
    },
    {
        "name": "F127",
        "normalProcess": "Allow one leveled compaction task to kick off another. Allow one leveled compaction task to kick off another. Leveled compaction wants to prevent multiple tasks from running at once, but this check also defeats the kick off another compaction if there is more work to do code in CompactionTask. So currently LCS relies completely on the every-five-minutes compaction check, which is not enough to keep up with heavy insert load."
    },
    {
        "name": "F128",
        "normalProcess": "Allow encryption only between datacenters. Enable encryption for data across the DC only. Make DC level Encryption option. 1) Modify EncryptionOptions to add inter_dc option. 2) Modify OutboundTCPConnection.connect() to check if it is in the same DC and if the encryption option is enabled."
    },
    {
        "name": "F129",
        "normalProcess": "Fix truncate allowing data to be replayed post-restart. truncate can still result in data being replayed after a restart."
    },
    {
        "name": "F130",
        "normalProcess": "Make iwriter final in IndexWriter to avoid NPE. NPE when writing SSTable generated via repair. A NPE is generated during repair when closing an sstable generated via SSTable build. It doesn't happen always. The node had been scrubbed and compacted before calling repair."
    },
    {
        "name": "F131",
        "normalProcess": "(CQL) update grammar to require key clause in DELETE statement. NPE on malformed CQL."
    },
    {
        "name": "F132",
        "normalProcess": "(CQL) allow numeric keyspace names in USE statement. Can't USE numeric keyspace names in CQL. Cassandra allows keyspace names to start with a digit or an underscore (see o.a.c.db.migration.Migration.isLegalName), but CQL's USE statement only accepts a CQL identifier, which must start with a letter. So there's no way to use a keyspace named 142 or_hi_in CQL."
    },
    {
        "name": "F133",
        "normalProcess": "(Hadoop) skip empty rows when slicing the entire row. Skip rows with empty columns when slicing entire row. We have been finding that range ghosts appear in results from Hadoop via Pig."
    },
    {
        "name": "F134",
        "normalProcess": "Fix handling of tombstone by SSTableExport/Import. SSTableImport/Export don't handle tombstone well if value validation != BytesType. SSTableImport/Export use the value validator even on tomstone, but for those the value is the local deletion time, so this don't necessarily validate (with UTF8Type for instance)"
    },
    {
        "name": "F135",
        "normalProcess": "Fix ColumnIndexer to use long offsets. 2GB row size limit in ColumnIndex offset calculation. Index offset is calculated using int instead of long resulting in overflow at 2GB row size. As a result affected columns can not be retrieved."
    },
    {
        "name": "F136",
        "normalProcess": "Improved CLI exceptions. need initClause when catch Exception and throw new Exception in cli. we added initCause to the Cli such that we could see more meaningful exception stacktrace when certain exception is thrown."
    },
    {
        "name": "F137",
        "normalProcess": "Only count compaction as active (for throttling) when they have successfully acquired the compaction lock. Compaction throttling can be too slow. Compaction throttling needs to know how many active compactions are running (to divide bandwith for each active compaction). The way active compaction is counted can be broken because it counts the number of active threads in the executor BUT the thread starts by acquiring a lock."
    },
    {
        "name": "F138",
        "normalProcess": "Display CLI version string on startup. Cassandra-CLI command should have --version option. Implementing cassandra-cli --version command line option would make it easier to write bug reports and check the versions of tools in use. Or if you want to make it a CLI command inside the tool, I don't know. --version option seems to be the standard way."
    },
    {
        "name": "F139",
        "normalProcess": "Hadoop make CFIF try rpc_address or fallback to listen_address. Make CFIF use rpc_endpoint prior to trying endpoint. we probably need to attempt to use the rpc_endpoint address first, and then fall back to the gossip endpoint if we don't get what we want."
    },
    {
        "name": "F140",
        "normalProcess": "Hadoop accept comma delimited lists of initial thrift connections. Unify support across different map/reduce related classes for comma seperated list of hosts for initial thrift port connection."
    },
    {
        "name": "F141",
        "normalProcess": "ColumnFamily min_compaction_threshold should be >= 2. cassandra-cli allows setting min_compaction_threshold to 1."
    },
    {
        "name": "F142",
        "normalProcess": "Pig add 0.8+ types and key validation type in schema. Pig Storage Handler: Add >=0.8.1 types, Guess right type for Key in Schema."
    },
    {
        "name": "F143",
        "normalProcess": "Fix completely removing column metadata using CLI. unable to remove column metadata via CLI."
    },
    {
        "name": "F144",
        "normalProcess": "CLI `describe cluster;` output should be on separate lines for separate versions. Schema versions output should be on separate lines for separate versions."
    },
    {
        "name": "F145",
        "normalProcess": "Fix changing durable_writes keyspace option during CF creation. creating column family sets durable_writes to true."
    },
    {
        "name": "F146",
        "normalProcess": "Avoid locking on update when no indexes are involved. Avoid lock contention in hint rows.hint writes are keyed by target IP, to make replay efficient. However, this means that we'll hit a lot of lock contention in table.apply where we synchronize for potential index updates."
    },
    {
        "name": "F147",
        "normalProcess": "Fix assertionError during repair with ordered partitioners. AssertionError when adding a node and doing repair, repair hangs."
    },
    {
        "name": "F148",
        "normalProcess": "Correctly serialize key_validation_class for avro. CFM.toAvro() incorrectly serialises key_validation_class defn."
    },
    {
        "name": "F149",
        "normalProcess": "Don't expire counter tombstone after streaming. AssertionError in PrecompactedRow.write via CommutativeRowIndexer during bootstrap."
    },
    {
        "name": "F150",
        "normalProcess": "Prevent nodes that failed to join from hanging around forever. If node fails to join a ring it will stay in joining state indefinately. While attempting to add a new node to my ring something went wrong and I had to terminate the node on ec2. After this the node keeps appearing in the ring command in joining state and never goes away."
    },
    {
        "name": "F151",
        "normalProcess": "Remove incorrect optimization from slice read path. ReadResponseSerializer.serializedSize() calculation is wrong."
    },
    {
        "name": "F152",
        "normalProcess": "Fix race in AntiEntropyService. ConcurrentModificationException during nodetool repair."
    }
]